# CLI Project

Console CLI application (user interface).

## Run
dotnet run

## Commands
help, list, create, exit



1. Загальна характеристика бізнес-логіки
Бізнес-логіка даного проєкту відповідає за керування колекцією об’єктів (Item) у межах консольного застосунку.
Під бізнес-логікою в даному контексті розуміється корисний код, який реалізує основні операції над предметною областю, незалежно від способу представлення даних користувачу.
Бізнес-логіка повністю відокремлена від шару представлення (CLI) та не містить залежностей від інтерфейсу користувача, що відповідає принципам Separation of Concerns та Single Responsibility.

2. Предметна область
Предметною областю застосунку є каталог об’єктів, де кожен об’єкт представляє собою логічну сутність із мінімальним набором властивостей.
На поточному етапі реалізації бізнес-логіка є спрощеною, оскільки основна мета практичної роботи — продемонструвати структуру та принципи побудови бізнес-компоненти.

3. Модель даних
Основною бізнес-моделлю є клас Item, який описує окремий елемент каталогу.
Основні властивості:
Id — унікальний ідентифікатор об’єкта;
Name — назва об’єкта.
Колекція об’єктів зберігається у внутрішньому сховищі в оперативній пам’яті застосунку.
Таке сховище виконує роль заглушки (stub) для майбутньої системи постійності.

4. Основні бізнес-операції
У межах бізнес-логіки реалізовано наступні операції:

4.1 Створення об’єкта
Операція створення нового об’єкта включає:
Отримання даних від користувача (назва об’єкта).
Валідацію введених даних.
Формування нового екземпляра Item.
Додавання об’єкта до колекції.
Дана операція інкапсулює правила створення об’єктів та не залежить від способу виклику (CLI або інший інтерфейс).

4.2 Перегляд каталогу
Операція перегляду каталогу повертає поточний список усіх створених об’єктів.
Бізнес-логіка не відповідає за форматування або спосіб відображення інформації, а лише надає дані для подальшого представлення.

5. Валідація даних
У межах бізнес-компоненти виконується базова валідація:
перевірка на порожні або некоректні значення;
контроль коректності створення нових об’єктів.
У подальшому дана логіка може бути розширена більш складними правилами перевірки.

6. Взаємодія з іншими компонентами
Бізнес-логіка не має прямих залежностей від:
консольного інтерфейсу;
графічного інтерфейсу;
систем збереження даних;
зовнішніх API.
Взаємодія з іншими компонентами здійснюється через чітко визначені інтерфейси або методи доступу до даних, що забезпечує гнучкість і розширюваність архітектури.

7. Розширення бізнес-логіки
Поточна реалізація бізнес-логіки підготовлена до подальшого розвитку, зокрема:
додавання нових властивостей до моделі Item;
реалізація збереження та завантаження каталогу;
інтеграція з базою даних або зовнішнім API;
використання складніших правил бізнес-валідації.


1. Призначення підсистеми збереження
Підсистема постійності відповідає за збереження та відновлення стану застосунку між його запусками.
Без механізмів збереження всі дані, створені користувачем під час роботи програми, зберігаються лише в оперативній пам’яті та втрачаються після завершення процесу.
Для підвищення зручності використання та відповідності сучасним вимогам програмного забезпечення, у проєкті передбачено механізм збереження даних каталогу об’єктів.

2. Обрана стратегія постійності
У межах даного проєкту використовується серіалізація даних у файли як основний механізм збереження.
Даний підхід обрано з таких причин:
простота реалізації;
відсутність потреби у зовнішніх сервісах або базах даних;
достатність для поточної предметної області (каталог об’єктів);
легкість розширення у майбутньому.

3. Формат серіалізації
Для серіалізації даних використовується формат JSON (JavaScript Object Notation).
Переваги JSON:
компактне текстове представлення;
простота читання людиною;
широка підтримка у платформі .NET;
зручність перетворення об’єктів у текст та назад.
JSON-файл містить повний опис стану каталогу, включаючи всі створені користувачем об’єкти.

4. Дані, що підлягають збереженню
У поточній реалізації зберігаються такі дані:
список об’єктів каталогу (Item);
ідентифікатори об’єктів;
назви об’єктів.
Ці дані є достатніми для повного відновлення стану каталогу при наступному запуску застосунку.

5. Процес збереження (Save)
Процес збереження включає такі етапи:
Отримання поточного списку об’єктів з бізнес-логіки.
Серіалізація колекції у формат JSON.
Запис отриманого тексту у файл у файловій системі.
Збереження ініціюється через окрему команду CLI або автоматично при завершенні роботи застосунку (передбачено архітектурно).

6. Процес відновлення (Load)
Процес відновлення даних виконується наступним чином:
Перевірка наявності файлу збереження.
Зчитування JSON-файлу з файлової системи.
Десеріалізація даних у об’єкти типу Item.
Відновлення колекції об’єктів у бізнес-логіці застосунку.
У випадку відсутності файлу збереження застосунок ініціалізується з порожнім каталогом.

7. Місце зберігання файлів
Файл збереження розміщується у спеціальній директорії користувача, призначеній для зберігання даних застосунків.
Приклад логічного розміщення:
Windows: каталог AppData/Local/<AppName>
Linux/macOS: прихована директорія в домашній папці користувача
Такий підхід відповідає рекомендаціям щодо роботи з файловою системою та не засмічує системні директорії.

8. Взаємодія з іншими компонентами
Підсистема постійності:
не залежить від CLI;
не виконує форматування даних для користувача;
працює виключно з бізнес-моделями.
Взаємодія з іншими шарами здійснюється через чітко визначені методи, що дозволяє замінити реалізацію збереження (наприклад, на базу даних) без змін у бізнес-логіці або інтерфейсі.

9. Заглушки та подальший розвиток
На поточному етапі допускається використання спрощеної реалізації або заглушок для підсистеми збереження, що відповідає вимогам технічного завдання.
У подальшому можливе розширення:
додавання версіонування файлів;
використання шифрування;
заміна файлового збереження на базу даних.


1. Призначення графічного інтерфейсу
Графічний користувацький інтерфейс призначений для візуальної взаємодії користувача з бізнес-логікою застосунку, яка вже реалізована та доступна через консольний інтерфейс (CLI).
GUI розглядається як альтернативний шар представлення, що не містить бізнес-логіки, а лише відображає дані та передає дії користувача до ядра застосунку.

3. Обрана технологія
Для реалізації графічного інтерфейсу передбачається використання WPF (Windows Presentation Foundation) на платформі .NET.
Причини вибору WPF:
нативний графічний фреймворк для Windows;
підтримка патерну MVVM;
тісна інтеграція з мовою C# та .NET;
зручна робота з колекціями та прив’язкою даних (data binding).
На поточному етапі графічний інтерфейс описується на рівні дизайну та архітектури, без повної реалізації.

3. Архітектурний підхід
Графічний інтерфейс будується відповідно до патерну MVVM (Model–View–ViewModel):
Model — бізнес-моделі (Item) та бізнес-логіка;
View — графічні елементи інтерфейсу (вікна, кнопки, списки);
ViewModel — проміжний шар, який адаптує бізнес-дані для відображення.
Такий підхід дозволяє:
ізолювати бізнес-логіку від інтерфейсу;
повторно використовувати ядро застосунку;
легко замінювати CLI або GUI.

4. Структура графічного інтерфейсу
Графічний інтерфейс складається з одного основного вікна, яке містить такі елементи:
Головне вікно (Main Window) — контейнер для всіх компонентів;
Список об’єктів — прокручуваний список елементів каталогу;
Текстові елементи — для відображення ідентифікатора та назви об’єкта;
Кнопки управління — створення нового об’єкта та оновлення списку.

5. Відображення каталогу об’єктів
Основним елементом GUI є візуальне представлення каталогу об’єктів.
Кожен елемент каталогу відображається у вигляді картки, яка містить:
назву об’єкта;
унікальний ідентифікатор;
додаткову текстову інформацію (за потреби).
Список карток є прокручуваним та оновлюється при зміні даних у бізнес-логіці.

6. Взаємодія з користувачем
Основні сценарії взаємодії:
перегляд списку об’єктів;
створення нового об’єкта через графічний діалог;
автоматичне оновлення списку після змін.
Усі дії користувача обробляються у ViewModel та передаються до бізнес-логіки без прямої залежності від GUI.

7. Інтеграція з існуючим CLI
CLI та GUI використовують одне й те саме ядро застосунку.
Це дозволяє:
тестувати бізнес-логіку через CLI;
використовувати GUI як альтернативний інтерфейс;
уникнути дублювання логіки.
Таким чином, консольний інтерфейс може використовуватися для розробки та налагодження, а графічний — для кінцевого користувача.

8. Подальший розвиток
У майбутньому графічний інтерфейс може бути розширений:
додаванням збереження та завантаження каталогу;
підтримкою редагування об’єктів;
інтеграцією з іншими типами інтерфейсів (веб або мобільний).

1. Загальні підходи до доставки застосунку
Доставка програмного забезпечення користувачу може здійснюватися різними способами залежно від типу застосунку та цільової аудиторії.
У контексті даного проєкту розглядаються такі підходи:
розповсюдження початкового коду через публічний репозиторій;
розповсюдження скомпільованих виконуваних файлів;
публікація релізу в GitHub.
Для навчального проєкту було обрано комбінацію двох підходів:
публічний репозиторій з початковим кодом та зібраний виконуваний файл у конфігурації Release.

2. Структура проєкту
Проєкт побудований за модульним принципом і включає такі основні частини:
виконуваний застосунок (CLI), що відповідає за користувацький інтерфейс;
внутрішні модулі, що містять бізнес-логіку та логіку збереження;
документація (README.md, DESIGN.md).
Усі складові об’єднані в єдиний .NET-проєкт, що спрощує збірку та розгортання.

3. Конфігурації збірки
Платформа .NET підтримує декілька режимів збірки, основними з яких є:
Debug — використовується під час розробки та налагодження;
Release — оптимізована конфігурація для кінцевого користувача.
Для доставки застосунку використовується Release-конфігурація, оскільки вона:
не містить відлагоджувального коду;
має кращу продуктивність;
призначена для реального використання.

4. Процес збірки застосунку
Збірка застосунку виконується стандартними засобами платформи .NET.
Основні кроки:
Встановлення .NET SDK відповідної версії.
Відновлення залежностей проєкту.
Компіляція застосунку у конфігурації Release.
Приклад команди збірки:

dotnet build -c Release

У результаті збірки формується виконуваний файл та необхідні бібліотеки (.dll), готові до запуску.

5. Формат доставки
Результуючі файли застосунку включають:
виконуваний файл (exe);
бібліотеки платформи .NET;
конфігураційні файли (за потреби).
Ці файли можуть бути:
надані окремим архівом для перевірки працездатності;
або опубліковані у вигляді GitHub Release з прикріпленими артефактами збірки.

6. Залежності та вимоги до середовища
Для запуску застосунку користувачу необхідно:
встановлена платформа .NET Runtime відповідної версії;
операційна система, сумісна з .NET (Windows, Linux, macOS).
Усі додаткові вимоги та інструкції з запуску описані у файлі README.md.

7. Документація процесу доставки
Інформація щодо:
способу збірки;
необхідних залежностей;
запуску застосунку
документується:
у файлі README.md репозиторію;
у даному дизайн-документі.
Це дозволяє користувачу або перевіряючому швидко зібрати та запустити застосунок.

8. Альтернативний варіант — GitHub Release
Як альтернативний спосіб доставки використовується публікація релізу в GitHub-репозиторії, де розміщуються:
скомпільовані виконувані файли;
опис версії;
інструкції з використання.
Такий підхід спрощує перевірку працездатності застосунку без необхідності локальної збірки.
